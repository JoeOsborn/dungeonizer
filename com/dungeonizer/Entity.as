package com.dungeonizer{  import flash.geom.Rectangle;	public class Entity 	{			  static const CATEGORY_NONE : int = 0;	  static const CATEGORY_MONSTER : int = 1;	  static const CATEGORY_PRINCESS : int = 2;	  static const CATEGORY_PLAYER : int = 3;	  	  public var slashForce : Number;	  	  public var health : int;	  public var maxHealth : int;	  public var map : Map;	  public var dungeon : Dungeon;	  	  public var size : Number;	  	  public var position : Vec;	  public var forward : Vec;	  public var side : Vec;	  public var up : Vec;	  public var velocity : Vec;	  	  public var full_max_speed : Number;	  	  public var category : int;	  	  public var hitTimer : Number;	  public var hitRecovery : Number;	  	  public var followers : Array;	  	  public var dead:Boolean;	  	  public var colliders:Array;	  	  public function Entity(	    mp : Map,	    px : Number, py : Number, 	    sz : Number,	    speed : Number)	  {	    followers = new Array();	    category = CATEGORY_NONE;	    maxHealth = int(sz);	    health = maxHealth;	    hitTimer = 0;	    hitRecovery = 0.5;		slashForce = 70.0;	    position = new Vec(px, py, 0);	    forward = new Vec(1, 0, 0);	    side = new Vec(0, 0, 1);	    up = new Vec(0, 1, 0);	    size = sz;	    full_max_speed = speed;	    velocity = new Vec(0,0,0);	    map = mp;	    dead = false;	    colliders = new Array();	  }	  public function addUnitCollider(x : Number, y : Number, w : Number, h : Number) : void	  {	    colliders.push(new Rectangle(x, y, w, h));	  }	  public function addFollower(e : Entity) : void	  {	    followers.push(e);	  }	  public function removeFollower(e : Entity) : void	  {	    followers.splice(followers.indexOf(e), 1);	  }	  public function get facing() : Number	  {	    var angle : Number = forward.toAngle();      if(angle >= (-Math.PI/4) && angle <= (Math.PI / 4))      {        angle = 0;      }      if(angle >= (Math.PI/4) && angle <= (3*Math.PI / 4))      {        angle = Math.PI/2;      }      if(angle >= (3*Math.PI / 4) && angle <= (-3*Math.PI/4))      {        angle = Math.PI;      }      if(angle >= (-3*Math.PI/4) && angle <= (-Math.PI/4))      {        angle = -Math.PI/2;      }      return angle;	  }	  public function get x() : Number	  {	    return position.x;	  }	  public function get y() : Number	  {	    return position.y;	  }	  public function get mass() : Number	  {	    return size;	  }	  public function get max_speed() : Number	  {	    return full_max_speed;	  }	  protected function slashCategoryAppropriate(e : Entity, st : int) : Boolean	  {	    return st == category;	  }  	public function collideBox(x : Number, y : Number, w : Number, h : Number) : Boolean  	{  	  for each(var rect : Rectangle in colliders)  	  {  	    var left : Number = position.x+rect.x*size;        var right : Number = left+rect.width*size;        if(left > right) { return false; }        var top : Number = position.y+rect.y*size;        var bottom : Number = top + rect.height*size;        if(bottom < top) { return false; }        var left2 : Number = x;        var right2 : Number = x + w;        var top2 : Number = y;        var bottom2 : Number = y + h;        if(bottom < top2)        {          continue;        }        if(top > bottom2)        {          continue;        }        if(right < left2)        {          continue;        }        if(left > right2)        {          continue;        }        return true;  	  }	  return false;  	}  	public function collideEntity(e : Entity) : Boolean  	{  	  for each (var r : Rectangle in e.colliders)  	  {  	    if(collideBox(r.x*e.size+e.position.x, r.y*e.size+e.position.y, r.width*e.size, r.height*e.size))  	    {  	      return true;  	    }  	  }  	  return false;  	}	  public function isSlashedBy(e : Entity, st : int, x : Number, y : Number, w : Number, h : Number) : Boolean	  {	    if(e == this) { return false; }	    if(hitTimer > 0) { return false; }	    	    if(collideBox(x, y, w, h))	    {	      return slashCategoryAppropriate(e, st);	    }		return false;	  }	  public function killedBy(e:Entity) : void	  {  	  	dead = true;      dungeon.removeEntity(this);	  }	  public function slashedBy(e:Entity, x:Number, y:Number) : void	  {	    var angle : Number = Math.atan2(position.y - e.y, position.x - e.x);	    velocity.x = ((e.slashForce / size)+size*2) * Math.cos(angle);	    velocity.y = ((e.slashForce / size)+size*2) * Math.sin(angle);	    health -= 1;	    if(health <= 0)	    {			  killedBy(e);	    }  	  hitTimer = hitRecovery;	    trace("slashed from angle " + angle);	  }	  public function wouldCollideAt(pt : Vec) : Boolean	  {	    var oldPos : Vec = position;	    position = pt;	    //check for walls within this box; do a real check for each of them	    for (var i : Number = Math.max(-1, pt.x-size-1); i <= Math.min(pt.x+size, Map.WIDTH); i++)	    {	      for (var j : Number = Math.max(-1, pt.y-size-1); j <= Math.min(pt.y+size, Map.HEIGHT); j++)	      {	        if(map.cellAtXY(Math.floor(i),Math.floor(j)) == map.WALL)	        {	          if(collideBox(i, j, 1, 1))	          {	            position = oldPos;	            return true;	          }	        }	      }	    }	    position = oldPos;	    return false;	  }	  public function preventWallEntrance(dt : Number) : void	  {      //is the new position a wall? if so, only slide      var multV : Vec = velocity.multiplyScalar(dt);      if(velocity.x != 0 && wouldCollideAt(new Vec(position.x+multV.x, position.y, position.z)))      {        velocity.x = 0;      }      if(velocity.y != 0 && wouldCollideAt(new Vec(position.x, position.y+multV.y, position.z)))      {        velocity.y = 0;      }      if(velocity.x != 0 && velocity.y != 0 && wouldCollideAt(new Vec(position.x+multV.x, position.y+multV.y, position.z)))      {        velocity.x = 0;        velocity.y = 0;      }	  }	  public function updateVelocity(dt : Number) : void	  {	    	  }	  public function updatePosition(dt : Number) : void	  {	    position = position.add(velocity.multiplyScalar(dt));	  }	  public function updateOrientation(dt : Number) : void	  {	    if(velocity.isNonZero())	    {  	    var new_forward : Vec = velocity.normalize();        var new_side : Vec = new_forward.cross(up);              forward = new_forward;        side = new_side;	    }	  }	  public function hitRecovered(dt:Number):void	  {	    return;	  }	  public function update(dt : Number) : void	  {	    //don't allow velocity changes when reeling from a hit  	  if(hitTimer > 0)  	  {  	    hitTimer -= dt;  	    if(hitTimer <= 0)  	    {  	      hitRecovered(dt);  	    }  	  }  	  else  	  {  	    updateVelocity(dt);  	  }  	  preventWallEntrance(dt);	    updatePosition(dt);      updateOrientation(dt);	  }	  	}}